//! # FCIDUMP Integral Reader (`ham::read_ints`)
//!
//! This module handles reading molecular integrals from a file in the `FCIDUMP` format
//! and populating the `Ham` data structure. It also determines which orbitals are
//! considered 'core' (frozen) based on the number specified in the input and the
//! ordering of diagonal Fock matrix elements (approximated by h_ii).
//!
//! ## FCIDUMP Format:
//! The `FCIDUMP` format is a standard text-based format storing one- and two-electron
//! integrals. Each line typically contains:
//! `integral_value p q r s`
//! where `p, q, r, s` are 1-based orbital indices.
//! *   `p=q=r=s=0`: Nuclear repulsion energy (scalar value).
//! *   `r=s=0`: One-electron integral h_pq.
//! *   `p,q,r,s > 0`: Two-electron integral (pq|rs) in chemist's notation.
//!
//! ## Indexing:
//! Integrals are stored internally using combined indices generated by `combine_2` and
//! `combine_4`, assuming 1-based input indices consistent with the FCIDUMP format.

extern crate lexical;
use lexical::parse;

use crate::ham::Ham;
use crate::utils::ints::{combine_2, combine_4, read_lines};
use crate::utils::read_input::Global;
use std::cmp::Ordering::Equal;

/// Stores the raw integral values read from the FCIDUMP file.
#[derive(Default, Debug)]
pub struct Ints {
    /// Nuclear repulsion energy.
    pub(crate) nuc: f64,
    /// Flattened vector storing one-body integrals h_pq.
    /// Indices are combined using `combine_2(p, q)` assuming p, q are 1-based.
    pub(crate) one_body: Vec<f64>,
    /// Flattened vector storing two-body integrals (pq|rs).
    /// Indices are combined using `combine_4(p, q, r, s)` assuming p, q, r, s are 1-based.
    pub(crate) two_body: Vec<f64>,
}

/// Reads integrals from an FCIDUMP file and initializes the `Ham` struct.
///
/// # Arguments
/// * `global`: A reference to the `Global` struct containing calculation parameters
///   (like `norb`, `norb_core`).
/// * `filename`: The path to the FCIDUMP file.
///
/// # Returns
/// A `Ham` struct populated with the nuclear repulsion energy, one- and two-electron
/// integrals, and lists of core and valence orbital indices.
///
/// # Process
/// 1. Initializes empty integral vectors sized appropriately based on `global.norb`.
/// 2. Reads the specified `filename` line by line.
/// 3. Parses each line according to the FCIDUMP format, storing the nuclear energy,
///    one-body integrals (h_pq), and two-body integrals (pq|rs) into the `Ints` struct
///    within `Ham`. Uses `combine_2` and `combine_4` for indexing, assuming 1-based
///    indices from the file.
/// 4. Determines core and valence orbitals:
///    - Extracts diagonal one-body integrals (h_ii) as proxies for Fock matrix elements.
///    - Sorts orbitals based on these diagonal elements.
///    - Assigns the lowest `global.norb_core` orbitals (by energy) to `ham.core_orbs`
///      and the rest to `ham.valence_orbs`.
///
/// # Panics
/// Panics if the file cannot be read or if parsing fails (e.g., non-numeric values where
/// numbers are expected). Header lines in FCIDUMP that do not start with a parsable float
/// are skipped.
pub fn read_ints(global: &Global, filename: &str) -> Ham {
    let mut ham: Ham = Ham::default();
    // ham.diag_computed = false;
    ham.ints.one_body = vec![0.0; combine_2(global.norb + 1, global.norb + 1)];
    ham.ints.two_body = vec![
        0.0;
        combine_4(
            global.norb + 1,
            global.norb + 1,
            global.norb + 1,
            global.norb + 1
        )
    ];
    if let Ok(lines) = read_lines(filename) {
        // Consumes the iterator, returns an (Optional) String
        for line in lines {
            if let Ok(read_str) = line {
                let mut str_split = read_str.split_whitespace();
                let i: f64;
                match parse(str_split.next().unwrap()) {
                    Ok(v) => i = v,
                    Err(_) => continue, // Skip header lines that don't begin with a float
                }
                let p: i32 = parse(str_split.next().unwrap()).unwrap();
                let q: i32 = parse(str_split.next().unwrap()).unwrap();
                let r: i32 = parse(str_split.next().unwrap()).unwrap();
                let s: i32 = parse(str_split.next().unwrap()).unwrap();
                if p == 0 && q == 0 && r == 0 && s == 0 {
                    ham.ints.nuc = i;
                } else if r == 0 && s == 0 {
                    ham.ints.one_body[combine_2(p, q)] = i;
                } else {
                    ham.ints.two_body[combine_4(p, q, r, s)] = i;
                }
            }
        }

        // Determine core and valence orbs using the diagonal Fock elements
        ham.core_orbs = Vec::with_capacity(global.norb as usize);
        ham.valence_orbs = Vec::with_capacity(global.norb as usize);

        // Sort diagonal elements in increasing order
        let mut fock_diag: Vec<f64> = Vec::with_capacity(global.norb as usize);
        let mut inds: Vec<i32> = Vec::with_capacity(global.norb as usize);
        for i in 0..global.norb {
            fock_diag.push(ham.one_body(i, i));
            inds.push(i);
        }
        fock_diag
            .iter()
            .zip(&inds)
            .collect::<Vec<_>>()
            .sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(Equal));

        for (i, (_, ind)) in fock_diag
            .into_iter()
            .zip(inds)
            .collect::<Vec<_>>()
            .iter()
            .enumerate()
        {
            if i < global.norb_core as usize {
                ham.core_orbs.push(*ind);
            } else {
                ham.valence_orbs.push(*ind);
            }
        }
        println!("Core orbs: {:?}", ham.core_orbs);
        println!("Valence orbs: {:?}", ham.valence_orbs);
    }
    // Note: Commented-out code for pre-computing screening information was removed.
    ham
}
