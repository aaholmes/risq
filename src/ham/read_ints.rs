//! # FCIDUMP Integral Reader (`ham::read_ints`)
//!
//! This module handles reading molecular integrals from a file in the `FCIDUMP` format
//! and populating the `Ham` data structure. It also determines which orbitals are
//! considered 'core' (frozen) based on the number specified in the input and the
//! ordering of diagonal Fock matrix elements (approximated by h_ii).
//!
//! ## FCIDUMP Format:
//! The `FCIDUMP` format is a standard text-based format storing one- and two-electron
//! integrals. Each line typically contains:
//! `integral_value p q r s`
//! where `p, q, r, s` are 1-based orbital indices.
//! *   `p=q=r=s=0`: Nuclear repulsion energy (scalar value).
//! *   `r=s=0`: One-electron integral h_pq.
//! *   `p,q,r,s > 0`: Two-electron integral (pq|rs) in chemist's notation.
//!
//! ## Indexing:
//! Integrals are stored internally using combined indices generated by `combine_2` and
//! `combine_4`, assuming 1-based input indices consistent with the FCIDUMP format.

extern crate lexical;
use lexical::parse;

use crate::config::GlobalConfig;
use crate::error::{RisqError, RisqResult};
use crate::ham::Ham;
use crate::utils::ints::{combine_2, combine_4, read_lines};
use crate::{risq_bail, risq_ensure};
use std::cmp::Ordering::Equal;

/// Stores the raw integral values read from the FCIDUMP file.
#[derive(Default, Debug)]
pub struct Ints {
    /// Nuclear repulsion energy.
    pub(crate) nuc: f64,
    /// Flattened vector storing one-body integrals h_pq.
    /// Indices are combined using `combine_2(p, q)` assuming p, q are 1-based.
    pub(crate) one_body: Vec<f64>,
    /// Flattened vector storing two-body integrals (pq|rs).
    /// Indices are combined using `combine_4(p, q, r, s)` assuming p, q, r, s are 1-based.
    pub(crate) two_body: Vec<f64>,
}

/// Reads integrals from an FCIDUMP file and initializes the `Ham` struct.
///
/// # Arguments
/// * `global`: A reference to the `Global` struct containing calculation parameters
///   (like `norb`, `norb_core`).
/// * `filename`: The path to the FCIDUMP file.
///
/// # Returns
/// A `Ham` struct populated with the nuclear repulsion energy, one- and two-electron
/// integrals, and lists of core and valence orbital indices.
///
/// # Process
/// 1. Initializes empty integral vectors sized appropriately based on `global.norb`.
/// 2. Reads the specified `filename` line by line.
/// 3. Parses each line according to the FCIDUMP format, storing the nuclear energy,
///    one-body integrals (h_pq), and two-body integrals (pq|rs) into the `Ints` struct
///    within `Ham`. Uses `combine_2` and `combine_4` for indexing, assuming 1-based
///    indices from the file.
/// 4. Determines core and valence orbitals:
///    - Extracts diagonal one-body integrals (h_ii) as proxies for Fock matrix elements.
///    - Sorts orbitals based on these diagonal elements.
///    - Assigns the lowest `global.norb_core` orbitals (by energy) to `ham.core_orbs`
///      and the rest to `ham.valence_orbs`.
///
/// # Errors
/// Returns `RisqError` if:
/// - The file cannot be read or parsed
/// - The file contains invalid FCIDUMP format
/// - Integral values are inconsistent with the system size
pub fn read_ints<P: AsRef<std::path::Path>>(config: &GlobalConfig, filename: P) -> RisqResult<Ham> {
    let filename = filename.as_ref();
    let mut ham: Ham = Ham::default();
    
    // Initialize integral storage
    let norb = config.n_orbs as i32;
    ham.ints.one_body = vec![0.0; combine_2(norb + 1, norb + 1)];
    ham.ints.two_body = vec![0.0; combine_4(norb + 1, norb + 1, norb + 1, norb + 1)];
    
    // Read FCIDUMP file
    let lines = read_lines(filename)
        .map_err(|e| RisqError::io_error(filename, e))?;
    
    let mut line_number = 0;
    for line_result in lines {
        line_number += 1;
        let read_str = line_result
            .map_err(|e| RisqError::io_error(filename, e))?;
        
        let mut str_split = read_str.split_whitespace();
        
        // Parse integral value (first field)
        let integral_str = str_split.next().ok_or_else(|| {
            RisqError::FcidumpParse {
                message: "Missing integral value".to_string(),
                line: line_number,
            }
        })?;
        
        let integral: f64 = match parse(integral_str) {
            Ok(v) => v,
            Err(_) => continue, // Skip header lines that don't begin with a float
        };
        
        // Parse orbital indices
        let parse_index = |field: Option<&str>, name: &str| -> RisqResult<i32> {
            let field_str = field.ok_or_else(|| {
                RisqError::FcidumpParse {
                    message: format!("Missing {} index", name),
                    line: line_number,
                }
            })?;
            parse(field_str).map_err(|_| {
                RisqError::FcidumpParse {
                    message: format!("Invalid {} index: '{}'", name, field_str),
                    line: line_number,
                }
            })
        };
        
        let p = parse_index(str_split.next(), "p")?;
        let q = parse_index(str_split.next(), "q")?;
        let r = parse_index(str_split.next(), "r")?;
        let s = parse_index(str_split.next(), "s")?;
        
        // Validate indices
        let max_index = norb;
        for (index, name) in [(p, "p"), (q, "q"), (r, "r"), (s, "s")] {
            if index < 0 || index > max_index {
                risq_bail!(FcidumpParse {
                    message: format!("Index {} out of range [0, {}]: {}", name, max_index, index),
                    line: line_number
                });
            }
        }
        
        // Store integral
        if p == 0 && q == 0 && r == 0 && s == 0 {
            ham.ints.nuc = integral;
        } else if r == 0 && s == 0 {
            let idx = combine_2(p, q);
            risq_ensure!(idx < ham.ints.one_body.len(), IndexError {
                index: idx,
                size: ham.ints.one_body.len(),
                operation: format!("one_body storage at line {}", line_number)
            });
            ham.ints.one_body[idx] = integral;
        } else {
            let idx = combine_4(p, q, r, s);
            risq_ensure!(idx < ham.ints.two_body.len(), IndexError {
                index: idx,
                size: ham.ints.two_body.len(),
                operation: format!("two_body storage at line {}", line_number)
            });
            ham.ints.two_body[idx] = integral;
        }
    }

    // Determine core and valence orbs using the diagonal Fock elements
    ham.core_orbs = Vec::with_capacity(config.n_orbs);
    ham.valence_orbs = Vec::with_capacity(config.n_orbs);

    // Sort diagonal elements in increasing order
    let mut fock_diag: Vec<f64> = Vec::with_capacity(config.n_orbs);
    let mut inds: Vec<i32> = Vec::with_capacity(config.n_orbs);
    for i in 0..config.n_orbs {
        fock_diag.push(ham.one_body(i as i32, i as i32));
        inds.push(i as i32);
    }
    let mut sorted_pairs: Vec<(f64, i32)> = fock_diag
        .into_iter()
        .zip(inds)
        .collect();
    sorted_pairs.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(Equal));

    for (i, (_, ind)) in sorted_pairs.iter().enumerate() {
        if i < config.n_core {
            ham.core_orbs.push(*ind);
        } else {
            ham.valence_orbs.push(*ind);
        }
    }
    
    println!("Core orbs: {:?}", ham.core_orbs);
    println!("Valence orbs: {:?}", ham.valence_orbs);
    
    Ok(ham)
}
